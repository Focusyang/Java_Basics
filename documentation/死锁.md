#### 死锁

##### 定义

不同的线程分别占用对方需要的同步资源不放弃，都在等对方放弃自己需要的同步资源，就形成了线程的死锁。

![image-20230801110838386](..\pictures\死锁.png)

##### 诱发死锁原因

- 互斥条件
- 占用且等待
- 不可抢夺
- 循环等待

以上四个条件同时出现就会触发死锁

##### 解决死锁

死锁一旦出现，基本很难人为干预，只能尽量规避。可以考虑打破上面的诱发条件

- 针对条件一：互斥条件基本无法破坏。因为线程需要通过互斥解决安全问题
- 针对条件二：可以考虑一次性申请所有所需资源，这样就不存在等待的问题
- 针对条件三：占用部分资源的线程在进一步申请其他资源时，如果申请不到，就主动释放掉已经占用的资源。
- 针对条件四：可以将资源改为线性顺序。申请资源时，先申请序号较小的，这样避免循环等待问题。

##### 补充

除了使用synchronized同步机制处理线程安全问题之外，还可以使用jdk5.0提供的lock方式

步骤一：创建Lock的实例，需要确保多个线程共用同一个Lock实例，需要考虑将此对象声明为static final

步骤二：执行lock（）方法，锁定对共享资源的调用

步骤三：unlock( )的调用，释放对共享数据的锁定

##### synchronized同步的方式与Lock对比

- synchronized不管是同步代码还是同步方法，都需要在结束一对{}之后，释放对同步监视器的调用

- Lock是通过两个方法控制需要被同步的代码，更灵活

- Lock作为接口，提供了多种实现类，适合更多复杂场景，效率更高。